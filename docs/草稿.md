直接简单的开始把。

目录结构考虑：

- dependencies           前置依赖
- docs     文档





**关于js 的context 对象的思考。** 

我一直想做一个全局的context, 这样函数只注册一遍就可以了。 

但是我并没有找到合适的方法来做这件事情。。。

也许，我该做多context ?

在加载文件的时候， 我是否需要每个文件都新建一个context ？

还是借鉴node.js 的里面， 把文件内容使用一个函数包起来？ 

应该要使用一个函数包起来，因为包起来的话，就可以重复的加载这个文件多次。 

有关js函数调用的问题， 回头再考虑。 



OK， 那么采用类似方式来做把， 在文件的头尾加上下面的内容

```javascript
// add to first line
function (module, exports, params){
  

  // add to line end
}
```

可变参数怎么搞？

记录值， 然后做展开。 



**如何储存和显示实体数据呢？**

~~使用 graph 来保存数据~~

用户使用实体graph里面的节点来表示外键

然后做几个 `CreateEntityData` 和`SightNode` 互相转换的函数？

所有的实体类型都需要转换成js文件， 以及注册类型到 v8里面。  转换js文件单方面转换即可，注册的话也是。

~~每一个实体生成一个js文件。~~

当实体的 input 节点被链接的时候， 对对象进行赋值操作。 

当实体的 output 节点被引用的时候， 反向激活的时候进行取值操作。

这里有一个问题， 那就是 对象的名称的问题。 

使用单独的 yaml 文件保存节点数据。 

- 先使用一个文件来 保存数据把， 就叫 `entities.yaml`  :heavy_check_mark:
- 这个文件在加载的时候 会生成一个 templateNode  :heavy_check_mark:
- 实体的代码生成相关的函数 使用一个js 函数来编写 :heavy_check_mark:
  - 代码可以写在 sight-base 插件里面。
  - 具体格式还要再考虑。
- 实体的 UI 操作相关的代码 暂时不做。
- 实体节点取消掉 process 节点， 但是添加两个 object in 和 object out 节点
  - 这里是不是添加 step 流程比较好点？ 
  - 因为 单纯的禁用 process 节点还是比较简单的， 但是修改类型有点难了？  好像也不是很难。 这个不是问题， 问题是 变量名该怎么操作？  使用 step 看起来比较友好。
    - 使用变量声明节点的话， 节点会多出差不多2个， 是有点啰嗦了， 但是目前也还能接受
    - 使用阶段的话， 就更加的紧凑了， 但是鉴于目前的情况，后面再加阶段把。
  - 使用 object 代替流程节点， 产生流程的效果； 这个给 template 添加一个属性， 应该是简单的。 :heavy_check_mark:
  - 全新添加一个叫做 step 的东西， 这个是阶段。 属于节点的附加操作。  *TODO* 
- 添加一个新的 API `getOtherSideValue(selfPort, addressOrName, portName)` 
  - 调用成功 返回 对应端点的值， 其他情况返回 undefined
  - 实体可以使用这个 API 获取 变量声明节点的 变量名。   然后直接 `insertSource`
- 转换成 templateNode 之后， 还需要添加一个 Type  :heavy_check_mark:
- 查看实体列表， 和修改实体字段， 以及继承， 这些后面在弄把。  TODO*





- `templateNodes.js` 文件   :heavy_check_mark:
- 应用 `a/b/c` 这种模板地址    :heavy_check_mark:
- 模板节点指针转换成字符串地址   :heavy_check_mark:

如何生成代码呢？ 

直接使用一个 stream 手动追加内容？  好像也不是不行。。  那就试试把。



**生成代码使用的中间件**

这里的目的是构建出了中间件， 在之后修改代码上就会比较方便了。 

我现在在考虑是否有必要构建这样一层中间件？ 

本来做中间件是为了节点可以生成代码使用的， 而目前的话， 我打算让节点直接生成Js代码， 而且我已经实现了部分这样的内容。 

我现在想直接使用tree-sitter 做中间层， 不额外写一层自己的中间层了。 

新的思路大概是这样的。 

- `jscode`
- `tree-sitter`
- format
  - 或者说叫 wrapper ，对于JAVA来说， 就是在代码外面套一层包和类
- code
  - common code
    - c系语言的大多数基本语句是固定的， 这些语句写一套代码直接转换即可。
  - target code specify
    - 部分不一样的语法， 单独指定。



我无法考虑没有定义的东西， 要不搞完其他的再弄这个？

也不是不可以， 因为部分内容在节点的生成代码里面可能是需要指定的。 比如新增一个函数， 新定义一个类之类的。 

使用自己的中间层 还有一个可能的好处是 可以自行优化部分代码。 但是这个工作也许可以考虑在生成代码的时候做上一些， 这个现在其实可以不做。 如果真的要做， 等待后面再搞也行。

考虑了一下，这个留到最后再做应该是可以的。 现在想先弄这个， 主要是想打通链路， 怕前面都弄好了，这个没法做。 

但是， 仔细考虑一下，就发现其实没必要

- 如果后面碰到了什么问题， 解决它就好了。
- 先弄 节点生成代码的话， 后面搞这个的时候 ， 很多问题就已经出现过了， 不怎么再多需要改动这部分。
- 节点生成目标代码的地方， 也没有做多少内容， 很多问题现在应该是没有考虑到的。



**Project 相关的草稿内容**

程序的目录结构是什么样子的？

- plugins

  - 启动就加载的插件

- lib-plugins

  - 需要才会加载的插件

- libs

  - 动态库

- exe

- \*.so/\*.dylib    动态库

  

项目的 目录结构是什么样子的？

- project.yaml
- nodeStyles.yaml



**插件草稿**

先弄文件夹形式的插件， 每个文件夹里面应该存在一个`package.js` 文件

```javascript
return {
  name: 'aa',
  version: '1.0',
  author: 'xxx',
};
```



**构建目标**

本着不过度设计的原则， 只考虑到当前的情况。 

所以考虑的实现方案是 任何一个插件都可以提供0~N个构建目标， 用户可以选择这些构建目标中的一个进行构建。 

在构建的时候， 这些构建目标将会传递给 模板节点的 generateCode 等函数。



**实体插件想法**

提供下列函数 （这里的列表更偏向于插件， 而非实体插件）

- 节点右键菜单
- 链接右键菜单
- 背景右键菜单
- 生成 代码生成的相关函数
- input版本和 output版本的节点  | 只显示相关的节点，其他的屏蔽掉
- Input 节点和 output节点同名的时候， 生成函数会产生一个覆盖问题[bug]
  - 解决方案就使用非覆盖方法， 并且生成 列表给 `$$`
- 返回多个函数， 用数组把。   `$$.stmts`
- 这里处理掉 this, 以及变量名的问题
  - 在节点里面就使用类似 `$.uid.this = $.uid()`  的写法？ 、
    - 这个写法产生的结果是 `this.uid = ${$.uid()};`  
  - 变量名最好能自动协调？ 
  - 比如使用 `$$.requireVarName();`  这里将会产生一个变量名
  - 目前来说， 这方面的需求还是太模糊了。
- 还是先弄dao 层插件把， 把节点抽象出一堆来， 上面的问题应该都可以解决了。



疑问😳

- 是否提供命令？ 
  - 这样做的好处是
  - 不需要提供过多的函数给插件， 插件还能提供更多的功能
  - 使用一个字符串来定义一个命令， 然后命令绑定一个行为
  - 这样命令还能绑定到按键上
  - 换句话说，就是抄 vs code 的相关机制



我打算， 先弄一下几个插件， 弄几张图之后再填充 实体插件部分的东西。

**node.js-redis 插件设计**

- 先弄常规的读取保存
- DAO的拓展节点后面再弄。



**Portal**

一个 In, 一个 Out

主要用于传送关系， 其实只是产生一个图上的便利而已。

并不会对图的生成结果产生什么作用。  

Portal 是一个间接的链接， 其效果等同于直接链接。

**变量声明**

一个 输出端点 如果链接到一个变量声明节点的输入端点， 那么则会产生一条 `let varName = xxx;` 的语句。

如果一个变量声明节点的输出端点链接到另外一个节点的输入端点， 那么生成的语句则为 `varName`。

其他问题列表

- 变量名的问题处理。
  - 所有变量的变量名都不应该一样
    - 如果用户输入了相同的变量名， 则应该提示一个错误
  - 变量名应该可以自动提示
    - 变量输出模式下的 变量名应该可以自动提示
    - 自动提示的备选内容 做成 cpp 的缓存更好一些把。 
    - cpp 的缓存允许使用 js 函数添加，修改，和删除
    - 添加一个函数？ 每次输入之后 调用一下？    应该添加一个获取备选项的函数
      - onAutoComplete(text) ?   返回一个字符串数组，表示备选项
      - 返回一个 null or undefined 表示没有值
      - 给一个选项 allowAutoComplete 表示是否启用
    - 我打算先使用一个 combo box 来弄， 而且默认情况下 如果备选项稀少的话， 应该都是使用一个 combo box 
  - 变量名怎么保存， 怎么还原？ 
    - 这应该是要放到 graph 上绑定的把。
    - 在 graph 上申请一片内存， 给个 key ？ 应该也可以。 
    - 目前不做节点， 模板节点的专属内存， 使用一个 key 指定， 任何节点都可以访问那个 key 对应的内存。
- 这里涉及到一个类型动态转变的问题， 也许可以叫做伪装类型。  这个可以后面在做。
- 节点的事件 处理
  - 为了在重新加载的时候生效
  - 为了完成 切换的效果
  - 为了完成事件， 应该需要模板端点。
- js 线程 编译的函数， 使用 ui 线程的 Isolate 无法执行。 应该是需要重新编译
  - 把源代码丢给 wrapper， 让 wrapper 在执行前编译一次
- 剩余工作
  - 图纸加载的时候需要把相关的函数事件调用一下  (onReload)
  - out 的类型根据 in 的数据自动变化
  - 公共库， 以及可能的事件函数互相调用
  - v8pp 研究，以及重构 js 相关代码
    - 来一波小重构把
    - 顺便把 节点相关的代码也尝试重构一下 
    - 抽象出一个新的基类 SightBaseNode 之类的
    - 以及看看怎么调整注入 js 的类型，以及如何注入 c++变量
  - auto complete 函数的调用位置再考虑
  - 加一个 onInit 事件
- 公共函数， 以及导出函数怎么处理？
  - 使用 module.globals
- 节点在 parse 的时候， 该怎么插入一条新的链路呢。
  - list of list  最简单的。   :heavy_check_mark:
    - 还是用这个把， 最简单了。
    - 有没有可能使用一个伪的 ？
    - 混合一个或者几个索引来做
    - 
  - ~~分隔符~~
    - node1
    - 分隔符
    - node2



**Selection 的一些想法**

想做一个类用于记录全部的相关项目， 并且这些会投射到 UI 上面。 

简单点搞把， 弄一个列表记录选择的节点和链接。 

多项编辑暂时不做把。 



### 组件

我想尽可能的重复利用代码。 

所以， 应该会添加几个新的函数， 所有存在这些函数的节点 都视为组件。 

- 组件可以反向激活
- 组件是依附于节点的， 所以，组件的主要功能是给节点提供功能
  - `beforeGenerate()` 函数
    - 在 `generate`函数之前调用， 按照组件的顺序依次执行。
    - `onReverseActive()`函数调用之前不会调用， 但是可以手动调用。



**关于生成链接相关的代码的问题**

这个是我最想解决的问题， 其他的组件相关的 倒不是问题。。 

这个需要左边节点和右边节点的变量名。 

生成的代码使用的模板 差不多是 `new SightConnection($.left.varName(), $.right.varName(), $.priority)`

先不管数据传递的问题， 先想想， 怎么能恰当的把组件的函数调用了。

链接的附加组件暂时不显示 。

。。。

突然有个新想法， 那就是不做链接的组件， 而是像之前的实体那样， 写一个默认的生成函数。 

然后给 graph 选择 

这样好像也可以？ 

组件的话， 就单独的应用到节点上即可。 

```javascript
sight.connection.addCodeTemplate(function(c) {
  // c 包含更多的信息
  // 函数返回1个字符串出去， 表示运算结果。
  // 默认情况下， 链接在左右两边节点都执行完毕再执行
});
```

那就这样把， 看起来不怎么用改动旧的内容

现在需要对回调函数的参数进行确定。 

需要什么信息？ 

- connection 相关的信息，  包括 id, priority
- left 和 right 节点的信息 
  - 这个部分是重点， 也是难题所在。 
  - connection 需要能够访问到这两个节点的 helper 对象
  - 能够访问之后， 那两个节点设置一下那个值就好了。 
- 这个生成函数， 什么时候调用？
  - 在左右节点都生成结束之后 ？
  - 在一个链接的左右节点都生成结束之后， 调用该链接的 codeTemplate 函数

这样做了之后， 是简单了。 

但还是不能忘记组件相关的事情。 

现在考虑的一个组件有 vardeclare ， 这个用于增加附属的变量名称。 





### helper相关内容

这个相当于 主动提供的信息。 

让组件的代码就操作这个 helper 就可以了。 

常规提供的信息应该包括

- 变量名称 `varName`
- 

### code set 相关的内容
这里是用于插件生成代码的辅助工具。 
一个项目最终只会生成一个 code set  
而 code set  里面可以包含下面的内容
- class
  - function
  - field
    - var
    - constant
    - property
- function
- field

将其他操作全部变成操作这一个 code set 
最终将 code set 转换成 目标文件 

project -> code set -> target language 

graph -> 主要是函数内的代码
entity 主要是生成 生成其他内容

什么缓存啊啥的 暂时先不考虑，先把基本功能实现了 再说。 

所有的图都需要被装载进一个文件里面， 现在的话， 表示成一个类。 
**先做entity的生成把。。**
这个怎么做比较好呢。。 

做一个 code set settings 的类， 给用户编辑。 
这个类里面去指定 代码的输出目录，  实体的模板类 

### spring 插件
这个插件的目的啥 使sight 具有输出web项目的能力。 
不用什么计划 或者ABCD ， 就需要什么做什么就可以了。

- 现在需要一个 type-list  给 httpRequest 来用。 
- 还需要一个 dynamic port list  动态端点列表 


## 数据生成模块

目前生成json 就可以了。。 
好像很简单。。  将整个图的数据写入一个json文件即可。。 

~~要不要加json 生成模板节点？~~   暂时不用

触发点在哪？  

先在 graph 上 放一个按钮测试一下吧。。 


