直接简单的开始把。

目录结构考虑：

- dependencies           前置依赖
- docs     文档





**关于js 的context 对象的思考。** 

我一直想做一个全局的context, 这样函数只注册一遍就可以了。 

但是我并没有找到合适的方法来做这件事情。。。

也许，我该做多context ?

在加载文件的时候， 我是否需要每个文件都新建一个context ？

还是借鉴node.js 的里面， 把文件内容使用一个函数包起来？ 

应该要使用一个函数包起来，因为包起来的话，就可以重复的加载这个文件多次。 

有关js函数调用的问题， 回头再考虑。 



OK， 那么采用类似方式来做把， 在文件的头尾加上下面的内容

```javascript
// add to first line
function (module, exports, params){
  

  // add to line end
}
```

可变参数怎么搞？

记录值， 然后做展开。 



**如何储存和显示实体数据呢？**

做一个叫做实体的graph ？

用户使用实体graph里面的节点来表示外键

然后做几个 `CreateEntityData` 和`SightNode` 互相转换的函数？

所有的实体类型都需要转换成js文件， 以及注册类型到 v8里面。  转换js文件单方面转换即可，注册的话也是。

每一个实体生成一个js文件。 

当实体的 input 节点被链接的时候， 对对象进行赋值操作。 

当实体的 output 节点被引用的时候， 反向激活的时候进行取值操作。

这里有一个问题， 那就是 对象的名称的问题。 



- `templateNodes.js` 文件   :heavy_check_mark:
- 应用 `a/b/c` 这种模板地址    :heavy_check_mark:
- 模板节点指针转换成字符串地址   :heavy_check_mark:

如何生成代码呢？ 

直接使用一个 stream 手动追加内容？  好像也不是不行。。  那就试试把。



**生成代码使用的中间件**

这里的目的是构建出了中间件， 在之后修改代码上就会比较方便了。 

我现在在考虑是否有必要构建这样一层中间件？ 

本来做中间件是为了节点可以生成代码使用的， 而目前的话， 我打算让节点直接生成Js代码， 而且我已经实现了部分这样的内容。 

我现在想直接使用tree-sitter 做中间层， 不额外写一层自己的中间层了。 

新的思路大概是这样的。 

- `jscode`
- `tree-sitter`
- format
  - 或者说叫 wrapper ，对于JAVA来说， 就是在代码外面套一层包和类
- code
  - common code
    - c系语言的大多数基本语句是固定的， 这些语句写一套代码直接转换即可。
  - target code specify
    - 部分不一样的语法， 单独指定。



我无法考虑没有定义的东西， 要不搞完其他的再弄这个？

也不是不可以， 因为部分内容在节点的生成代码里面可能是需要指定的。 比如新增一个函数， 新定义一个类之类的。 

使用自己的中间层 还有一个可能的好处是 可以自行优化部分代码。 但是这个工作也许可以考虑在生成代码的时候做上一些， 这个现在其实可以不做。 如果真的要做， 等待后面再搞也行。

考虑了一下，这个留到最后再做应该是可以的。 现在想先弄这个， 主要是想打通链路， 怕前面都弄好了，这个没法做。 

但是， 仔细考虑一下，就发现其实没必要

- 如果后面碰到了什么问题， 解决它就好了。
- 先弄 节点生成代码的话， 后面搞这个的时候 ， 很多问题就已经出现过了， 不怎么再多需要改动这部分。
- 节点生成目标代码的地方， 也没有做多少内容， 很多问题现在应该是没有考虑到的。



**Project 相关的草稿内容**

程序的目录结构是什么样子的？

- plugins

  - 启动就加载的插件

- lib-plugins

  - 需要才会加载的插件

- libs

  - 动态库

- exe

- \*.so/\*.dylib    动态库

  

项目的 目录结构是什么样子的？

- project.yaml
- nodeStyles.yaml



**插件草稿**

先弄文件夹形式的插件， 每个文件夹里面应该存在一个`package.js` 文件

```javascript
return {
  name: 'aa',
  version: '1.0',
  author: 'xxx',
};
```



**构建目标**

本着不过度设计的原则， 只考虑到当前的情况。 

所以考虑的实现方案是 任何一个插件都可以提供0~N个构建目标， 用户可以选择这些构建目标中的一个进行构建。 

在构建的时候， 这些构建目标将会传递给 模板节点的 generateCode 等函数。



**实体插件想法**

提供下列函数 （这里的列表更偏向于插件， 而非实体插件）

- 节点右键菜单
- 链接右键菜单
- 背景右键菜单
- 生成 代码生成的相关函数
- input版本和 output版本的节点  | 只显示相关的节点，其他的屏蔽掉
- Input 节点和 output节点同名的时候， 生成函数会产生一个覆盖问题[bug]
  - 解决方案就使用非覆盖方法， 并且生成 列表给 `$$`
- 返回多个函数， 用数组把。   `$$.stmts`
- 这里处理掉 this, 以及变量名的问题
  - 在节点里面就使用类似 `$.uid.this = $.uid()`  的写法？ 、
    - 这个写法产生的结果是 `this.uid = ${$.uid()};`  
  - 变量名最好能自动协调？ 
  - 比如使用 `$$.requireVarName();`  这里将会产生一个变量名
  - 目前来说， 这方面的需求还是太模糊了。
- 还是先弄dao 层插件把， 把节点抽象出一堆来， 上面的问题应该都可以解决了。



疑问😳

- 是否提供命令？ 
  - 这样做的好处是
  - 不需要提供过多的函数给插件， 插件还能提供更多的功能
  - 使用一个字符串来定义一个命令， 然后命令绑定一个行为
  - 这样命令还能绑定到按键上
  - 换句话说，就是抄 vs code 的相关机制



我打算， 先弄一下几个插件， 弄几张图之后再填充 实体插件部分的东西。
